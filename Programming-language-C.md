# 1. Первое знакомство с С

Ctrl + Alt + N - компиляция <br>
Ctrl + Shift + B - перекомпиляция

## 1.1 - 1.2 Этапы трансляции программы в машинный код. Стандарты 

Файлы программы обрабатываются текстовым препроцессором, затем попадают в руки компилятора и лексического анализатора. В результате компиляции образуются объектные файлы. Линкер соединяет все объектные файлы проекта в одно целое, собирает реализации функций из библиотеки, прототипы которых объявлены в программе и тд. Затем формируется и исполняется конечный файл .exe

## 1.3 Установка компилятора gcc и Visual Studio Code на ОС Windows

### 1. Скачивание компилятора

Скачиваем в инете MinGW, далее сверху сверху All packages -> выбираем mingw32-gcc-bin , mingw32-gcc-g++-bin , mingw32-make-bin , mingw32-gdb-bin . -> Installation -> Apply changes

Далее. Настройки win -> система -> доп. параметры системы -> переменные среды -> системные переменные -> Path -> Создать (C:\MinGW\bin)

Для проверки, установилось ли все корректно: cmd -> gcc. Нужно, чтобы вылезло это: <br>
gcc: fatal error: no input files <br>
compilation terminated.

### 2. Скачивание интегрированной среды для разработки

VSCode скачиваем.

Устанавливаем полезные расширения: 

a) C/C++ (можно компилировать прям тут в VSCode и дебагать)

b) Code Runner (теперь можно запускать сочетанием Ctrl + Alt + N)

### 3. Компиляция и исполнение текстового файла программы

```markdown
gcc <имя_файла>
.\a
```

### 4. Настройка компилятора под стандарт C99 

Переходим в каталог .vscode -> tasks.json -> args: [... , "-std=c99", ...]

Плюсом добавляем этот флаг в компилятор через комбинацию Ctrl + Alt + N.

Для этого File -> preferences -> settings -> пишем code runner run in terminal , ставим галку

Тут же пишем run code configuration, ищем Executor Map. В параметре "c" пишем gcc -std=c99

## 1.4 Структура и понимание работы программы "Hello, World!"

/* ... */ , // ...- это комментарии

#include ... - это директива препроцессора. Все директивы начинаются с #

В тексте программы обязательна функция main. Перед ним идет ключевое слово int, означает, что выдавать будет integer. Отсутствие параметров можно задать словом void в списке параметров.

Почему return 0? Так тоже нужно. Это показывает, что функция завершила все действия корректно

## 1.5 Двоичная, шестнадцатеричная и восьмеричная системы счисления

Десятичное и двоичное - понятно

Обычно первый бит данных уходит под знак: 1 - отриц, 0 - положительное

# 2. Переменные и арифметические операции

## 2.1 Переменные и их базовые типы. Модификаторы unsigned и signed

Если положительный числовой литерал по значению превышает диапазон типа unsigned long long, то компилятор выдает предупреждение или ошибку

Тут происходит полное копирование данных: 

```markdown
char byte_memory;
byte_memory = 100;
char a;
a = byte_memory;
```

Нужно придерживаться этих правил при создании имени переменных:

* максимальная длина кода внутри модуля составляет 63 символа;
* максимальная длина за пределами модуля составляет 31 символ;
* имена существительные;
* чувствителен к регистру;
* можно использовать: a-z, A-Z, 0-9, _;
* в качестве первого символа не может идти цифра.

Базовые типы данных языка C:

* char - 1 байт
* short [int] - 2 байта
* int - 4 байта
* long [int] - 8 байтов
* long long [int] - 8 байтов
* float - 4 байта
* double - 8 байтов
* long double 10 байтов

Два модификатора:
* unsigned - беззнаковый;
* signed - знаковый;

short, int, long, long long - по умолчанию все __знаковые__!

char - непонятно. Зависит от компилятора

К вещественным эти модификаторы применять __нельзя__

## 2.2 Присваивание, числовые и символьные литералы, sizeof

```C
dec = 100;
hex = 0x1FA;
oct = 0123;
```

это есть разные способы задания числа: в десятичном виде, шестнадцатеричном, восьмеричном.

Операция присваивания состоит из левого операнда и правого.

Сначала идет название переменной, затем числовой литерал.

У литералов тоже есть модификаторы:

* U или u - использование модификатора unsigned;
* L или l - тип long;
* LL или ll - тип long long.

Пример:

```C
dec = 100L;
```

### Функция sizeof

Это функция для определения размера типов данных или переменных

```markdown
sizeof(<тип \ имя_переменной>)
sizeof имя_переменной
```

## 2.3 Потоки ввода/вывода. Функции putchar() и getchar()

Существет три стандартных потока:

* stdout - стандартный поток вывода;
* stdin - стандартный поток ввода;
* stderr - стандартный поток вывода ошибок.

У каждого потока есть свои буферы. Сначала данные попадают в буффер, а затем в ввод/вывод

Рассмотрим функции, часто использующиеся на практике: (для всех должна быть прописана директива препроцессора #include <stdio.h>)

* putchar() - для вывода символов через поток stdout;
* printf() - для форматного вывода строки;
* perror() - вывод ошибки в виде строки через поток stderr;
* getchar() - чтение одного символа из потока stdin;
* scanf() - форматный ввод данных из потока stdin.

### Функции getchar() и putchar()

Определение функции getchar:

```C
int getchar(void);
```

При компиляции и исполнении программы с этой функцией, программа ожидает на вход символы. Для корректной работы в VSCode нужно донастроить среду. Переходим в settings.json -> code-runner.runInTerminal: true.

Определениен функции putchar:

```C
int putchar(int ch);
```

Функция возвращает код того символа, который был помещен в поток вывода

Пример кода:

```C
#include <stdio.h>

int main(void)
{
    int value = getchar();
    int res = putchar(value);
    printf("\n%d\n", res);

    return 0;
}
```

При запуске программы буферы ввода и вывода пустые. Но при их использовании, эти буфферы могут заполняться. При завершении, все буферы автоматически очищаются.

## 2.4 Функция printf() для форматированного вывода

Определение функции: 

```C
int printf(const char* format, ...);
```

const char* format - указание на строку, в которой определен формат для вывода информации в stdout; троеточие означает, что мы можем поставить любое количество аргументов. Функция возвращает int, и принимает значение выведенных символов в стандартный поток данных stdout

Спецификаторы для printf:

* %d или %i - int, char, short;
* %u - unsigned;
* %o - восьмеричный unsigned;
* %x или %X - шестнадцатеричный unsigned;
* %f или %F - float в десятичной дроби;
* %e или %E - float в экспоненциальном виде;
* %c - вывод символа;
* %s - строка;
* %% - символ процента.

Данные типов char и short при выводе функцией printf автоматически приводятся к типу данных int.

При выводе достаточно большого числа например long long может понадобится суффикс перед спецификатором:

* l - суффикс для типов long или unsigned long, для даблов тоже можно;
* ll - суффикс для типов long long или unsigned long long;
* L - суффикс для типов long double.

Пример:

```C
printf("value = %ld\n", var_i)
```

Флаги спецификаторов для printf:

* десятичное число - максимальная ширина выводимой информации;
* знак "-" - выравнивание по правому краю;
* знак "+" - отображение чисел со знаками "+" и "-";
* цифра 0 - заполнение незначащими нулями;
* пробел - задает отображение положительных чисел с пробелом в начале, а отрицательных с минусом;
* символ "#" - задает отображение префикса числа (0x - шестн. , 0 - для восьм.).

Пример: 

```C
printf("[%10d]\n", var_i);
```

Пример кода:

```C
#include <stdio.h>

int main (void)
{
    int var_i = -1283;
    double var_d = 54.5344;
    
    printf("[%12.7d]\n", var_i);
    printf("[%12.2f]\n", var_d);

    return 0;
}
```

## 2.5 Функция scanf() для форматированного ввода

Определение функции: 

```C
int scanf(const char* format, ...);
```

Функция выводит число прочитанных и записанных переменных из потока ввода

Спецификаторы для scanf:

* %d - целое, приводится к int;
* %i - целое, в десят., восьм., шест., сс.
* %u - unsigned приводится к unsigned int;
* %o - в восьм.,
* %x, %X - в шестн.,
* %f, %e, %g, %F, %E, %G - вещественное, приводится к float;
* %c - символ в соответствии с таблицей;
* %s - строка.

При использовании функции scanf вторым и далее аргументам в начале нужно ставить знаки амперсандов. Так C будет воспринимать запись &<name_of_variable> как идентификатор памяти, по которому расположена ячейка памяти <name_of_variable>

Для того, чтобы за раз считывать и записывать данные из стандартного вводного потока, используем такой синтаксис: 

```markdown
scanf("%d%d...", &var_1, &var_2, ...)  // и соответственно другие спецификаторы для других типов данных
```

Если между спецификаторами в форматной строке поставить пробел, то теперь на ввод можно писать символы:
* все так же друг за другом;
* через пробел;
* через символ переноса строки;
* через символ табуляции.

Если поставить запятую, то теперь на ввод можно подать символы формата: <symb_1>,<symb_2>  // без пробелов!!

Модификаторы scanf:

* h - для short int (%hd или %hi - short int, %hx, %ho, %hu - unsigned short);
* hh - для char (%hhd - signed char, %hhu - unsigned char);
* l - (%ld, %li - long int, %lx, %lo, %lu - unsigned long, %lf, %lg, %le - double);
* L - (%Lf, %Lg, %Le - long double);
* ll - (%lld - long long int, %llu - unsigned long long int);
* Цифры - максимальная ширина ввода;
* "*" - пропуск данных

Пример пропуска данных:

```C
#include <stdio.h>

int main (void)
{

    unsigned int price = 0;
    double weight = 0.0;

    int res = scanf("%*llu; %u; %lf", &price, &weight);
    printf("res = %d: price = %d, weight = %.2f\n", res, price, weight);

    return 0;
}
```

## 2.6 Сложение, вычитание, умножение и деление

Когда мы делим целое число на целое, то результат получаем целый, причем дробная часть при делении отбрасывается. Чтобы поделить так, чтобы в результате получилось вещественное число, нужно привести обе переменные к типу double 

```C
short a = -5;
int b = 10;

double res_1 = (double)a / (double)b;
```

Все операции имеют свой приоритет, который задается правилами математики. За исключением того, что любые унарные операторы по приоритету выше бинарных. Также приоритет операций можно менять круглыми скобками.

## 2.7 Операции деления по модулю, инкремента и декремента

* Деление по модулю - % (тот же приоритет, что и при умножении/делении) работает только с целыми числами.
* Инкремент - ++
* Декремент - --

Отрицательные числа и операция деления по модулю: 

```C
int res_1 = -10 % 4;
int res_2 = -10 % -4;
int res_3 = 10 % 4;
```

Если левый операнд отрицательный, то результат тоже
Иначе: результат положительный

```markdown
res_1: -2
res_2: -2
res_3: 2
```

Оператор инкремента увеличивает число на 1

```C
#include <stdio.h>

int main (void)
{
    int count = 0;

    printf("count = %d\n", count);
    count++;
    printf("count = %d\n", count);

    return 0;
}
```

Формы инкремента:

* Префиксная ++count
* Постфиксная count++  

Форма инкремента влияет на порядок действий при присваивании значения другой переменной. В префиксной форме сначала идет повышение инкремента, а затем присваивание этого нового значение другой переменной. В постфиксной форме сначала происходит присваивание, а затем инкремент

## 2.8 Арифметические операции +=, -=, *=, /=, %=

Смысл этих упрощенных арифметических операций в следующем: При использовании оператора присваивания идет обращение к одной ячейке памяти, данные оттуда забираются, с ними происходят действия и результат записывается уже в __другую__ ячейку памяти. У упрощенных арифметических операций работа происходит гарантированно всего лишь с одной ячейкой.

1. count = count + 3;  // пример операции присваивания
2. count += 3;  // пример упрощенной арифм. операции

# 3. Условные операторы. Директивы препроцессора

## 3.1 Булевый тип. Операции сравнения. Логические И, ИЛИ, НЕ

* true - любое ненулевое значение;
* false - 0.

Со стандарта C99 в языке появился новый тип данных: булевый тип. Его размер = 1 байт, то есть это char.

```C
_Bool fl_view = 0; 
printf("%d", sizeof(fl_view));
```

Вывод:

```markdown
1
```

На деле же таким корявым типом данных никто не пользуется. Вместо этого используют тип данных bool из заголовочного файла <stdbool.h>. Теперь можно использовать две константы: true (1) и false (0).

Все операции сравнения возвращают тип данных bool. ! Важно, что на равенство нельзя проверять вещественные числа!

Приоритеты логических операций: (1 - наивысший, 3 - наименьший):

1. Логическое унарное НЕ (!);
2. Логическое И (&&);
3. Логическое ИЛИ (||).

Если во время проверки комплексного логического условия, включающего операцию И, обнаруживается, что первый аргумент этой операции false, то второй аргумент даже не будет высчитываться. Ответ сразу будет выдан как false.

## 3.2 Условный оператор if. Конструкция if-else

```markdown
if(<выражение>) оператор;
```

```markdown
if(<выражение>) {
    оператор 1;
    оператор 2;
    ...
    оператор N; 
}
```

```markdown
if(<выражение>) оператор;
else оператор;
```

## 3.3 Условное тернарное выражение

```markdown
<выражение 1> ? <выражение 2> : <выражение 3>
```

```C
int main(void)
{
    double a = 7.5, b = -3.43;
    double max_ab = a > b ? a : b;

    printf("max_ab = %.2f\n", max_ab);

    return 0;
}
```

## 3.4 Оператор switch. Ключевое слово break

```markdown
switch(<выражение>) {
    case <константа 1>:
        [операторы]
    case <константа 2>:
        [операторы]
    ...
    [default: операторы]
}
```

<выражение> - может быть любое выражение, которое выдает целочисленное значение. константами могут быть любые целые числа, представленные литералами. default выполняется в случае , когда ни одна из меток выше не исполнилась.

Подводный камень оператора switch в том, что когда встречается нужная нам метка, исполняются вообще все операторы case , которые стоят ниже этой метки. Для предотвращения, выходим из оператора словом break.

* оператор switch лучше выносить в отдельную функцию и прерывать словом return;
* программу следует прописывать так, чтобы после метки case вызывалась функция вместо ряда операторов;
* никогда не используем вложенные операторы switch.

## 3.5 Битовые операции И, ИЛИ, НЕ, XOR. Сдвиговые операции

1. Битовая операция НЕ (~)
   
```markdown
x ~x
0 1
1 0
```

2. Битовое И (&). С помощью этой битовой операции можно проверять, включены ли биты. А также, можно выключать биты.

```markdown
x y И(&)
0 0 0
0 1 0
1 0 0
1 1 1
```

3. Битовое ИЛИ (|). С помощью этой битовой операции обычно включают биты.

```markdown
x y ИЛИ(|)
0 0 0
0 1 1
1 0 1
1 1 1
```

4. Битовый XOR (^). С помощью этой битовой операции можно переключать биты.

```markdown
x y XOR(^)
0 0 0
0 1 1
1 0 1
1 1 0
```

Приоритеты:

НЕ -> И -> XOR -> ИЛИ

Приоритет всех битовый операций ниже, чем у операций сравнения и существенно ниже обычных арифметических операций 

5. Смещение бит вправо, влево. (>> , <<)

```C
#include <stdio.h>
 
int main(void)
{
    unsigned char x = 40;                   // 00101000
    printf("x = %d\n", x); 
 
    x = x >> 1;                       // 00010100 (число 20)
    printf("x = %d\n", x);
 
    x = x >> 2;                       // 00000101 (число 5)
    printf("x = %d\n", x); 
 
    x = x >> 1;                       // 00000010 (число 2)
    printf("x = %d\n", x);
 
    x = x >> 1;                       // 00000001 (число 1)
    printf("x = %d\n", x);
 
    x = x << 1;                       // 00000010 (число 2)
    printf("x = %d\n", x);
 
    x = x << 2;                       // 00001000 (число 8)
    printf("x = %d\n", x);
 
    return 0;
}
```

Приоритет сдвиговых битовых операций >> и << одинаковый, но выше, чем у операций сравнени и меньше чем у арифметических операций.

## 3.6 Генерация псевдослучайных чисел. Математическая библиотека

int rand(void); - возвращает псевдослучайную величину от 0 до RANDMAX >= 32767. Эта функция и константа определены в заголовочном файле stdlib.h

При каждом отдельном запуске мы будем получать одни и те же значения этих псевдослучайных величин.

Можно сменить зерно псевдослучайности: 
srand(...) , тогда последовательность поменяется, но все равно при каждом отдельном запуске комбинация чисел будет одинаковой.

Обойти это можно функцией time(NULL) , которая возвращает текущее время в секундах. #include <stdio.h>. Это значение времени подставляется как зерно псевдослучайности.

```C
#include <stdio.h>
#include <stdlib.h>
 
int main(void)
{
    int r_1 = rand();
    int r_2 = rand();
 
    printf("%d, %d, %d, %d, %d\n", r_1, r_2, rand(), rand(), rand());
 
    return 0;
}
```

### Функция math.h

Функция

```C
int abs(int)  // Вычисление модуля целочисленного значения.
double fabs(double)  // Вычисление модуля вещественного значения.
```

Функции округления

```C
double round(double)  // Округление вещественного значения до ближайшего целого.
double floor(double)  // Округление вещественного значения до наименьшего целого.
double ceil(double)  // Округление вещественного значения до наибольшего целого.
double trunc(double)  // Отбрасывание дробной части вещественного числа.
```

Степенные функции

```C
double sqrt(double)  // Вычисление квадратного корня от вещественного значения.
double cbrt(double)  // Вычисление кубического корня от вещественного значения.
double pow(double x, double y)  // Возведение числа x в степень y.
double exp(double)  // Вычисление экспоненты от вещественного значения.
double log(double)  // Вычисление натурального логарифма.
double log2(double)  // Вычисление логарифма по основанию 2.
double log10(double)  // Вычисление десятичного логарифма.
```

Тригонометрические функции

```C
double sin(double)  // Вычисление синуса угла, заданного в радианах.
double cos(double)  // Вычисление косинуса угла, заданного в радианах.
double tan(double)  // Вычисление тангенса угла, заданного в радианах.
double asin(double)  // Вычисление арксинуса угла (возвращает радианы).
double acos(double)  // Вычисление арккосинуса угла (возвращает радианы).
double atan(double)  // Вычисление арктангенса угла (возвращает радианы).
```

## 3.7 Директивы макропроцессора #define и #undef

#define - это макродиректива , которая позволяет создать пользовательские макроопределения (макросы). Синтаксис этой директивы: #define <макроимя> [тело макроса]

```C
    switch(item) {
    case MENU_TRANSL:
        printf("Translate words\n");
        break;
    case MENU_ADD:
        printf("Add words\n");
        break;
    case MENU_EXIT:
        printf("Exit\n");
        break;
    default:
        printf("Incorrect menu item\n");
    }
```

директива #undef отменяет определенный выше макрос по кодовому имени.

Определять можно например так:

```C
#define LESSON          32
#define other_lesson    LESSON + 1
#define PHELLO          printf("Hello!\n")
# define SPACE          ' '
#define PHELLO2         printf("Hello!\n");
```

И нельзя вот так:

```C
define STUDY            "C/C++"
#define NEW_DEFINE      #define A 2
```

## 3.8 Макросы. Операции # и <raw>##</raw>

Макросы функции: при определении макроса можно прописать круглые скобки и указать принимаемые им параметры. После этого можно написать инструкцию, которая будет производиться над этими параметрами. Важно понимать, что параметры макроса-функции - это не переменные. Как и в случае с макросами, макрос-функция не вычисляет свое тело в момент компиляции. Она подставляет на свое место в программе тело функции , с вставленными вместо параметров значениями, а также, если есть, вставляет другие определенные в теле функции макросы.

```C
#include <stdio.h>
 
#define SQ_PR(A, B)     ((A) * (B))
#define TEXT(A, B)     "Square of rectangle (" #A ") x (" #B ")\n"
 
int main(void)
{
    int res = SQ_PR(2, 3);
    printf(TEXT(x-2, y-3));
 
    return 0;
}
```

Значок # при работе с макрос-функциями переводит параметр этой макрос-функции в текст

Знак ## подставляет в запись лексемы (название переменной) переданный параметр.

```C
#include <stdio.h>
 
#define SQ_PR(A, B)     ((A) * (B))
#define TEXT(A, B)      "Square of rectangle (" #A ") x (" #B ")\n"
#define X_N(N)          x ## N
 
int main(void)
{
    int x1 = 1, x2 = -2, x4 = 10;
    printf("%d\n", X_N(4));
 
    return 0;
}
```

## 3.9 Директивы #include и условной компиляции

Директива #include вставляет на свое место код заголовочного файла.

Согласно стандарту c99 можно записывать заголовочный файлы в <> и в "":
1. <> - поиск в системных каталогах, а затем, в рабочем
2. "" - поиск в рабочем каталоге, а затем, в системных

Если нужно подключить стандартные файлы, поставляемые с компилятором языка Си, то следует использовать угловые скобки. Если же подключаются свои файлы, то используем двойные кавычки.

Директивы условной компиляции: 

* #if - Проверка произвольного условия.
* #else - Определение ветки ?иначе?.
* #endif - Директива (метка) завершения фрагмента для условия.
* #ifdef - Сокращение от if defined. Позволяет делать проверку на наличие макроимени в текущем модуле.
* #ifndef - Сокращение от if !defined. Позволяет делать проверку на отсутствие макроимени в текущем модуле.
* #elif - Cокращение от else if. Позволяет делать проверку по ветке ?иначе?.
* #elifdef - Сокращение от else if defined. Для реализации проверки наличия макроимени по ветке ?иначе?.
* #elifndef - Сокращение от else if !defined. Для реализации проверки отсутствия макроимени по ветке ?иначе?.

В условных директивах компиляции можно использовать ключевое слово defined(<макроимя>). Оно выдаст true , если макроимя определено и false в противном случае.

```C
#define LANG_C
 
#if defined(LANG_C)
#   include <stdio.h>
#else
#   include <iostream>
#endif
 
int main(void)
{
         int x=5;
#ifdef LANG_C
         printf("%d\n", x);
#else
         std::cout << x << std::endl;
#endif
 
    return 0;
}
```

* в условиях директив можно использовать исключительно целочисленные литералы и макроимена;
* можно выполнять все булевы операции сравнения;
* логические связки;
* все бинарные арифметические и битовые операции;
* применять оператор defined

Можно делать так:

```C
#if SIZE > 0 ... #endif
#ifdef IS_CPP ... #endif
#if !defined(SIZE) ... #endif
#if defined(SIZE) ... #endif
#if SIZE >= 0 && SIZE <= 10 ... #endif
#if(SIZE == 1) ... #endif
#ifndef IS_CPP ... #endif
#if SIZE > 10-8 ... #endif
```

И нельзя вот так:

```C
#ifdef(IS_CPP) ... #endif
#if IS_CPP ... #endif
#if max_size > 1 ... #endif
```

# 4. Операторы циклов. Указатели

## 4.1 Оператор цикла while (цикл с предусловием)

```markdown
while(<условие>)
    оператор;
```

```markdown
while(<условие>) {
    оператор 1;
    ...
    оператор N;
}
```

Тело цикла - код внутри блока , создаваемого циклом.

Итерация - единоразовый проход тела цикла.

Переменные, созданные внутри цикла while существует только в пределах цикла. В любом месте программы помимо while , этой переменной не будет 

## 4.2 Оператор цикла for

Для ситуаций, когда при использовании цикла необходимо 1. Инициализировать переменные, 2. Исполнять тело цикла по конкретному условию, 3. В конце итерации изменять значения переменных, придумали цикл for.

```markdown
for([инициализация];[условие];[изменение значений])
    оператор;
```

```markdown
for([инициализация];[условие];[изменение значений]) {
    операторы;
}
```

Переменные, инициализированные внутри цикла for , снаружи этого цикла могут и не существовать. Дело в том, что разные компиляторы позволяют использовать эти переменные снаружи цикла, а некоторые нет.

Чтобы в первом блоке оператора for инициализировать сразу несколько переменных, можно воспользоваться оператором ","

Также эти блоки можно оставить пустыми. Они необязательны

## 4.3 Цикл do-while с постусловием. Вложенные циклы

Это цикл с постусловием:

```markdown
do {
    [оператор (один или несколько)]
} while(<условие>);
```

## 4.4 Операторы break, continue и goto

* break - досрочное прерывание работы оператора цикла;
* continue - пропуск итерации тела цикла;
* goto - безусловный переход по метке.

goto работает по принципу меток:

```markdown
goto <имя метки>
...
<имя метки> : продолжение программы
```

## 4.5 Указатели. Проще простого!

Оперативная память вычислительной машины представляет из себя последовательность ячеек размером в 1 байт. Каждая ячейка имеет свой уникальный номер, который называется адресом. Предположим, что в программе определена переменная типа char. В это времени в памяти устройства будет выделена ячейка памяти размером в 1 байт. При дальнейшем определении новых переменных в другом рандомном месте в памяти будет выделена еще память (4 ячейки для инт) для хранения данных этой переменной. При этом адресом этой переменной будет считаться адрес первой занимаемой ячейки. 

Указатели способны менять значение данных в разных ячейках, без указания на имя переменной. Указатели служат для записи и считывания данных из произвольных ячеек памяти. Вообще, указатели это те же самые переменные, причем целочисленные, которые хранят значение адреса ячейки.

Указатели:

* занимают в памяти 4 байта, для 32-х битных систем;
* занимают в памяти 8 байтов для 64-х битных систем.

Синтаксис объявления указателей:

```markdown
<тип данных> *<имя указателя>;
```

тип данных имеется в виду именно тот тип данных, на который будет указывать указатель

Пример:

```C
char x = *gpt; // считывание значения из ячейки памяти
*gpt = 100; // запись значения 100 в ячейку памяти
```

"*" называется операцией разыменовывания

Чтобы узнать адрес интересующей нас переменной, нужно использовать оператор амперсанда. Он выводит адрес этой переменной

Операция инициализации указателя: 

Тут происходит присвоение адреса указателю, а не изменение значения

```C
char* gpt = &d;
```

Операции +=, -= также корректно работают с указателями.

Чтобы в одну строчку объявить несколько указателей, нужно:

```C
short * a, *b, *c;
```

## 4.6 Приведение типов указателей. Константа NULL

Так можно адрес из одного указателя присвоить другому указателю

```C
ptr_arg = &arg;
ptr = ptr_arg;
```

Или:

```C
int arg = 777;
int *ptr_arg;
char* ptr;

ptr_arg = &arg;
ptr = ptr_arg;

*ptr = 1;
```

Для того чтобы в программе напрямую присваивать указателям адреса указателей, работающих с разными типами данных необходимо сделать приведение видов:

```C
ptr = (char *)ptr_arg;
```

Чтобы не маяться с приведением типов можно определить указатель на тип данных void: Тогда ему можно присваивать указатель любого типа , а также указателю любого типа можно будет присваивать указатель этого типа void. Он был введен для того, чтобы хранить адреса

```C
void *p;
```

У указателей возникают проблемы в следующих ситуациях:

* указатель ссылается на произвольную (не выделенную) область памяти и происходит запись некоторого значения
* в программе динамически выделяется память (с помощью функции malloc), но не освобождается (утечка памяти)

Бывают такие ситуации, когда у нас есть определенный указатель и нам необходимо узнать, ссылается ли он на конкретную область в памяти или на произвольную? То есть указатель не был инициализирован. Пользуются приемом: если указатель принимает какое-то конкретное значение, значит он еще не был инициализирован. Иначе ссылается на выделенную область в памяти. Что может выступать в качестве этого предопределенного значения? Константа NULL (она определена в заголовочном файле <stdio.h>). Если указатель принимает значение NULL, значит, что он еще не был инициализирован и его использовать нельзя!

```C
#include <stdio.h>
 
int main(void) 
{
         int arg = 5;
         int *ptr = NULL;
 
         if(ptr != NULL)
                   *ptr = 1;
         
         return 0;
}
```

## 4.7 Адресная арифметика

Значение указателя меняется на размер типа данных, для которого он определен

```C
#include <stdio.h>
 
int main(void) 
{
    int g = 4;
    int *ptr = &g;
 
    printf("ptr = %u\n", ptr);
         
    ptr++;
    printf("ptr = %u\n", ptr);

    return 0;
}
```

Когда мы работаем с указателями, операции с указателями работают по правилам адресной арифметики. Цель этой адресной арифметики не перебор ячеек памяти , а перебор данных. Поэтому операция инкремента увеличила адрес указателя на 4, вместо 1. Нельзя использовать вещественные значения и операции умножения, деления. Указатели между собой складывать запрещено. А вот находить разность между указателями можно. И такое поведение оправдано в рамках работы с элементами одного и того же массива.
 
Приоритет унарных операций убывает справа налево!

# 5 Массивы и строки

## 5.1 Введение в массивы

Для хранения однотипных данных в виде непрерывной последовательности байтов используются массивы. Массивы не являются отдельной структурой данной в C , а работают по принципу указателей.

Чтобы объявить массив , нужно использовать следующий синтаксис:

```markdown
<тип элементов массива> <имя массива>[<число элементов массива>]
```

В качестве размера массива можно использовать целые числа, целочисленные макроимена, а также операции, возвращающие целое значение. В качестве размера массива нельзя использовать переменные (формально можно, но нежелательно), вещественные значения, а также ноль.

Для занесения данных в массив можно использовать индексирование (индексы начинаются с нуля)

```C
#include <stdio.h>
#define TOTAL_MARKS                13
 
int main(void)
{
         int marks[TOTAL_MARKS];
         return 0;
}
```

```C
#include <stdio.h>
 
#define SIZE_BUFFER          1024
 
int main(void)
{
         // Корректные объявления
         double f[30];
         char buffer[SIZE_BUFFER];
         int marks[13];
         short ar[8 * 5];
         char bytes[sizeof(double)];
 
         // Некорректные объявления
         int n = 5;
 
         float func[21.5];   // вещественное количество элементов
         int array[n];       // нельзя было до стандарта C99
         int null_ar[0];     // размер должен быть больше нуля
 
         return 0;
}
```

В индексах хранится потенциальная опасность! Если программист будет индексом пытаться изменить или считать элемент не входящий в массив, то компилятор это не посчитает за ошибку, но это будет считаться UB (undefined behavior) и будет являться грубейшей ошибкой

Из-за того, что массивов как структуры данных нет в C очевидно предположить, что работа с ними происходит через указатели. А значит имя массива - это указатель на первый элемент, и с помощью операции разыменовывания указателя `buffer` можно также изменить значение в первом элементе массива!

## 5.2 Вычисление размера массива. Инициализация массивов.

Язык C позволяет прямо в программе вычислять размер массива при помощи известной команды `sizeof` . Применительно к массивам эта операция выдаст в результате количество байтов, занимаемый массивом. Это значение можно сохранить в специальном типе данных `size_t`:

```C
#include <stdio.h>
 
#define TOTAL_MARKS                13
 
int main(void)
{
         int marks[TOTAL_MARKS];
 
         marks[2] = 4;
         marks[0] = 2 * 3;
         marks[12] = 7 - 2;
//       marks[13] = 1;
 
         for(int i = 0; i < TOTAL_MARKS; ++i)
                   printf("%d ", marks[i]);
 
         return 0;
}
```

Для того, чтобы вывести переменную такого типа в `printf` , нужно использовать спецификатор `%zu` .

Если в момент объявления массива, мы знаем, какие данные он должен содержать, можно придать значения его элементам следующим образом (знак равно в данном случае выступает в роли инициализации массива, то есть после объявления в середине программы таким образать задать значения элементам массива будет уже нельзя!):

```C
int marks[TOTAL_MARKS] = {1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0};
```

Если в эти фигурные скобки передать `(k)` количество элементов меньшее, чем `(n)` количество элементов в массиве, то первые `k` элементов примут действительно те переданные в скобки значения, а остальные `n-k` примут значения `0`. Если `k = 0` , то массив будет состоять из нулей. Причем `k > n` элементов записывать в инициализаторе нельзя

Причем можно сделать так:

```C
int coords[] = {1, 2, 3};
```

В таком случае количество элементов массива автоматически станет равно `k (n = k)`

А также, с массивами можно проводить такие выкрутасы: 

```C
short digits[10] = {-1, [2] = 5, 18, [9] = -1};
for(int i = 0 ;i < sizeof(digits) / sizeof(digits[0]); ++i)
         printf("%d ", digits[i]);
```

## 5.3 Указатели на массивы

Указатель на массив появляется в момент объявления или инициализации массива. Вот чем указатель на массив отличается от обычного указателя:

* операция `sizeof` для указателя на массив возвращает число байт , занимаемых массивом в памяти устройства ;
* адрес указателя на массив формируется в момент его объявления (размещения в памяти устройства) и отсается неизменным на протяжении работы программы.

```C
#include <stdio.h>
 
int main(void) 
{
    short ar[] = {4, 3, 2, 1, 5, 6, 7};
    short *ptr_ar;
        
    ptr_ar = ar;
    return 0;
}
```

На самом деле под капотом `arr[indx]` выполняется `*(arr+indx)`

По этой причине можно использовать такой синтаксис `2[arr]`

## 5.4 Ключевое слово const с указателями и переменными

С помощью ключевого слова `const` можно запретить изменять значение указателя.

Но если мы пропишем следующим образом: `const short *ptr_arr;` , то тогда с помощью этого указателя нельзя будет менять значения переменных

Правильно было бы писать так: `short * const ptr_ar`

На самом деле ключевое слово `const` работает только на уровне компиляции. Компилятор контроллирует, чтобы те функции, которые были ограничены ключевым словом `const` не выполнялись нигде в программе

Язык C запрещает присваивать значения константного указателя обычному указателю

С переменными работает так же: 
```C 
#include <stdio.h>
 
int main(void) 
{
         const int code = 13;
 
         return 0;
}
```

## 5.5 Операции с массивами: копирование, вставка, удаление, сортировка

Копирование массива

```C
#include <stdio.h>

int main(void)
{
    float func_1[100] = {2.4, -3.5, 45.4, 56.2, 0, -5.43};
    float func_2[50];
    int size_1 = sizeof(func_1) / sizeof(func_1[0]);
    int size_1 = sizeof(func_2) / sizeof(func_2[0]);
    int size = (size_1 < size_2) ? size_1 : size_2;

    for(int i = 0; i < size; ++i)
        func_2[i] = func_1[i];

    for(int i = 0; i < size_2; ++i)
        printf("%d", func_2[i]); 
}
```

Вставка элемента в массив

```C
#include <stdio.h>

#define TOTAL_MARKS 10

int main(void)
{
    int marks[TOTAL_MARKS] = {3, 2, 5};
    int insert_indx = 2;

    for(int i = TOTAL_MARKS-1; i > insert_indx; --i) {
        marks[i] = marks[i-1];
    }

    marks[insert_indx] = 4;
}
```

Удаление элемента их массива

```C
#include <stdio.h>

#define TOTAL_MARKS 10

int main(void)
{
    int marks[TOTAL_MARKS] = {3, 2, 4, 5, 2, 4};
    int delete_indx = 3;

    for(int i = delete_indx; i < TOTAL_MARKS-1; ++i) {
        marks[i] = marks[i+1];
    }
}
```

Сортировка выбором
```C
#include <stdio.h>

#define TOTAL     20

int main(void)
{
    float ws[TOTAL] = {0.0f};
    size_t count = 0;  // размер массива
    size_t sz_ar = sizeof(ws) / sizeof(*ws);
    

    while(count < sz_ar && scanf("%f", &ws[count]) == 1)
        count++;

    for(int i = 0; i < count; ++i) {
        unsigned char min_ind = i;
        for(int j = i+1; j < count; ++j) 
            min_ind = ws[j] < ws[min_ind] ? j : min_ind;
        if(min_ind != i) {
            float tmp = ws[i];
            ws[i] = ws[min_ind];
            ws[min_ind] = tmp;
        }
    }
    
    for(int i = 0; i < count; ++i) {
        printf("%.2f ", ws[i]);
    }

    return 0;
}
```

## 5.6 Двумерные и многомерные массивы. Указатели на двумерные массивы

```markdown
<тип элементов> <имя массива>[число строк][число столбцов]
```

В памяти двумерный массив хранится точно так же, как и одномерный 

Обращение к game_pole[i][j] происходит по принципу: game_pole[i*m + j] , где 0 <= i <= n, 0 <= j <= m

Особенность инициализации двумерного массива

```C
char game_pole[3][4] = {1, 2, 3, 4};
```

```markdown
game_pole: [1, 2, 3], [4, 0, 0], [0, 0, 0]
```

Печать двумерного массива:

```C
#include <stdio.h>
 
int main(void) 
{
    char game_pole[3][3] = {1, 2, 3, 4};
 
    for(int i = 0;i < 3;++i) {
        for(int j = 0; j < 3; ++j)
            printf("%d ", game_pole[i][j]);
        printf("\n");
    }
 
    return 0;
}
```

Функция sizeof(<имя двумерного массива>) по-прежнему выдает количество занимаемых байтов.

Чтобы найти размерность двумерного массива:

```C
size_t bytes = sizeof(game_pole);
size_t bytes_row = sizeof(game_pole[0]);
size_t rows = sizeof(game_pole) / sizeof(game_pole[0]);
size_t cols = sizeof(game_pole[0]) / sizeof(game_pole[0][0]);
```

Так как элементы двумерного массива - это одномерные массивы, обращение к ним по индексу возвращает адрес первого элемента соответствующего массива. Его можно передать в указатель

Чтобы определить указатель на двумерный массив, воспользуемся синтаксисом: 
```C
char (*p_ar)[3] = arr;  // <тип данных> (*<имя указателя>)[вторая размерность] 
```

Причем если мы не поставим скобки, то это будет массив из трех указателей!:
```C
char *p_ar[3];
```

В частности указателем на двумерный массив можно пользоваться точно так же, как и обычным именем двумерного массива.

Первую размерность можно не указывать, она вычисляется, остальные прописывать обязательно

Можно так:

```C
int ar_7[3][3] = {{1, 2}, {3, 4}};
int ar_3[][3] = {{1, 2, 3}, {4, 5, 6}};
short ar_2[2][3] = {1, 2, 3, 4, 5, 6};
float ar_4[][3] = {1, 2, 3, 4, 5, 6};
short ar_1[2][3] = {{1, 2, 3}, {3, 4, 6}};
```

Нельзя так:

```C
int ar_6[2][3] = {{1, 2}, {3, 4}, {5, 6}};
long ar_5[2][] = {{1, 2, 3}, {4, 5, 6}};
```

## 5.7 Строки. Способы объявления, escape-последовательности

Строки записываются в двойных кавычках, а символы в одинарных

В C нет типа данных "строка". Поэтому используют массив типа char
```C
char str[] = {'D', 'O', 'B', 'R', 'I', 'N', '\0'};
```
`\0` - маркер конца строки. Каждая корректная строка обязана иметь этот символ. Он учитывается функциями для определения конца строки.

Также строки можно инициализировать так:
```C
char s[] = "Dobrin";
```

Тогда служебный симвой `\0` ставится автоматически.

При инициализации строки вида:
```C
char buffer[512] = "Hello, World!"
```

Символ `\0` будет стоять сразу после символа `'!'` , что покажет нам конец строки. После служебного символа идет мусор

```C
char b[] = "Hel" "lo"
            ", World!";
char sp[] = "Hello, \
World"
```

Компилятор соединяет это в одну строку и создает массив.

### Важно! Все строковые литералы помещаются в неизменяемую область памяти, поэтому являются неизменяемыми

```C
char* ch_ptr = "Dobrin";
char ch_arr[] = "Dobrin";
```

Через `ch_ptr` мы можем лишь читать строку, но не изменять ее. Потому что эта строка находится в неизменяемой области памяти. А `ch_arr` - позволяет нам изменять любой символ, так как является массивом и находится в стековом фрейме (об этом позже)

По этой причине указатель на строковые литералы желательно выделять ключевым словом `const`:
```C
const char* ch_ptr = "Dobrin";
```

Что, если в строке планируется содержать двойные кавычки? Тогда нужно экранировать символы:
```C
char s[] = "I love programming on \"C\" language";
```

Чтобы вывести строку на экран, можно воспользоваться функцией `puts`:
```C
puts(s);
```

Экранирование и спецсимволы:

* \n - 0x0A - перевод на новую строку
* \r - 0x0D - возврат каретки
* \t - 0x09 - символ табуляции
* \' - 0x27 - экранирование апострофа (одинарная кавычка)
* \" - 0x22 - экранирование двойной кавычки
* \? - 0x3F - экранирование вопросительного знака
* \\\ - 0x5C - экранирование обратного слеша
* \0 - 0x00 - символ конца строки (число 0)
* \x<число> - символ с указанным шестнадцатеричным значением
* \uxxxx - символ с кодом xxxx в кодировке UNICODE (добавлено в стандарте C99)

## 5.8 Ввод/вывод строк в стандартные потоки

Строки можно вывести функцией `printf` с помощью спецификатора `%s` :
```C
printf("%s", "Hello world");
```

Или так:
```C
char str[] = "Hello world!";
printf("%s", str);
```

Также строки можно легко выводить функцией `puts` , которая определена в заголовочном файле `<stdio.h>` :
```C
puts(str);
```
Более того, `puts` переводит курсор на новую строку

Функция scanf очень не безопасна для ввода строк, потому что считывание идет до первого пробельного символа. В случае его отсутствия , запись будет продолжаться в выделенный массив даже за его пределами, что делает программу непредсказуемой. Лечится это достаточно просто. Нужно указать количество читаемых символов в спецификаторе `%s` :
```C
char bf[10];
scanf("%9s", bf);  // обратите внимание, что тут операция получения 
                   // адреса не нужна. bf - это указатель на первый 
                   // элемент типа char 
```

Ширина чтения - 9 байтов, потому что 10-ым идет запись специального символа `\0`

Есть функция `gets` , которой запрещено пользоваться даже в своих проектах, потому что она является опасной с точки зрения того, что позволяет злоумышленникам затирать данные. От ее использования отказались.

Итак , можно использовать функцию `fgets` для того, чтобы вводить строки:
```C
char bf[10];
fgets(bf, sizeof(bf), stdin);  // первый аргумент - указатель на массив 
                               // второй аргумент - размер читаемых данных
                               // третий аргумент - поток файла, из которого идет чтение
                               // stdin - определен в <stdio.h>
```

При всем этом, функция `fgets` не читает sizeof(bf) байт. Она читает sizeof(bj) - 1 байт, записывает их, и потом записывает `\0` . Главное неудобство этой функции заключается в том, что она после себя оставляет символ перевода строки. Он формируется при нажатии Enter.

Также для ввода строк можно воспользоваться посимвольным чтением, в цикле считывать по одному символу известной нам функцией `getchar`

```C
#include <stdio.h>

int main (void)
{
    char bf[10];

    int max_len = sizeof(bf), i = 0;
    char *ptr = bf, ch;

    while((ch = getchar()) != '\n' && ch != EOF && i < max_len-1)
        ptr[i++] = ch;

    ptr[i] = '\0'
    
    puts(bf);

    return 0;
}
```

## 5.9 Строковые функции strlen(), strcpy(), strncpy(), strcat()

1. Копирование одной строки в другую

```C
#include <stdio.h>

int main (void)
{
    char source[100] = "Source string";
    char destination[10];

    const char *src = source;
    char *dst = destination;
    int max_len_copy = sizeof(destination);

    while(*src != '\0' && max_len_copy-- > 1)
        *dst++ = *src++;
    *dst = '\0';

    puts(destination);
}
```

В языке C уже есть 2 стандартные функции, которые выполняют функцию копирования:  (функции определены в заголовочном файле `<string.h>`)
```C
char* strcpy(char* dest, const char* src);
char* strncpy(char* dest, const char* src, int max_len);
```

dest - строка, куда производится запись, src - строка, которую копируем, max_len - максимальное количество копируемых символов

```C
#include <stdio.h>
#include <string.h>

int main(void)
{
    char source[100] = "Source string";
    char destination[20];

    srcpy(destination, source);

    return 0;
}
```

Данная программа имеет в себе уязвимость: если source будет состоять более чем из 10 символов, то функция srcpy выйдет за пределы масива destination. 

```C
#include <stdio.h>

int main(void)
{
    char source[100] = "Source string";
    char destination[20];
    int max_len = sizeof(destination) - 1  // - '\0'

    srcpy(destination, source);
    destination[max_len] = '\0';  // если по какой то причине, этого символа нет, 
                                  // то в конец мы запишем. 
                                  // Если есть, то ничего плохого не будет

    return 0;
}

2. Определение длины строки. (Длина строки - это количество символов до '\0').

```C
#include <stdio.h>

int main(void)
{
    char str[100] = "Length of the string";

    const char *buf = str;
    size_t length = 0;

    while(*buf++)
        length++;
    
    printf("length = %zu\n", length);

    return 0;
}
```

В заголовочном файле `<string.h>` объявлена функция, которая это делает:
```C
size_t strlen(const char* buf);
```

```C
#include <stdio.h>
#include <string.h>

int main(void)
{
    char str[100] = "Length of the string";

    size_t length = strlen(str);

    return 0;
}
```

3. Сложение (конкатенация) двух строк.

Функции объединения строк объявлены в заголовочном файле `<string.h>`

```C
char* strcat(char* dest, const char* src);
char* strncat(char* dest, const char* src, int max_add);
```

max_add - максимальное число добавляемых символов к строке

```C
#include <stdio.h>
#include <string.h>
 
int main(void) 
{
    char str_cat[100] = "Sergey";
    char str[15] = "Balalkirev";
 
    strcat(str_cat, str);
    printf("%s", str_cat);
 
    printf("\n");
 
    size_t max_add = sizeof(str) - strlen(str) - 1;
    strncat(str, str_cat, max_add);
    str[sizeof(str) - 1] = '\0';
    printf("%s", str);
 
    return 0;
}
```

## 5.10 Строковые функции сравнения, поиска символов и фрагментов

Строки называются равными, если их длины совпадают и элементы на соответствующих местах тоже. Даже с учетом того, что первая строка - это массив большей длины, чем второй , которым является вторая строка, лексикографическое сравнение строк идет до первого встретившегося символа конца строки.

Алгоритм сравнивания строк можно реализовать так:
```C
#include <stdio.h>
#include <string.h>

int main (void) {
    char s1[12] = "Hello";
    char s2[10] = "Hello";

    const char *str1 = s1;
    const char *str2 = s2;

    int i = 0;
    for(; str[i] != '\0' && str2[i] != '\0'; ++i)
        if(str1[i] != str2[i]) {
            puts("Strings are not equal");
            return 0;
        }

    if(str1[i] != str2[i]) {
        puts("Strings are not equal");
        return 0;
    }
    return 0;
}
```

Библиотечный код (в заголовочном файле `<string.h>`), который реализует ту же функцию
```C
int strcmp(const char* str1, const char* str2);
int strncmp(const char* str1, const char* str2, size_t max_len);
```

Эти функции возвращают целочисленные значения. Если результат = 0 , то тогда str1 == str2. Если результат > 0, то str1 > str2 и при результате < 0: str1 < str2

```C
#include <stdio.h>
#include <string.h>
 
int main(void) 
{
    char s1[12] = "Hello";
    char s2[10] = "Hello";
 
    int res = strcmp(s1, s2);
    if(res == 0)
        puts("Strings are equal!");
    else
        puts("Strings are not equal!");
 
    return 0;
}
```

Функции поиска символов и подстрок:

```C
char* strchr(const char* str, int val);  // выполняет поиск символа слева-направо с кодом val в строке str
char* strrchr(const char* str, int val);  // выполняет поиск символа справа-налево с кодом val в строке str
char* strstr(const char* str, const char* find);  // выполняет поиск слева-направо подстроки find в строке str
char* strpbrk(const char* str, const char* find);  // выполняет поиск слева-направо любого символа из подсткроки find в строке str.
```

## 5.11 Строковые функции sprintf(), atoi(), atol(), atoll() и atof()

Функция `sprintf` - выводит результат в указанную строку buffer

```C
int sprintf(char* buffer, const char* format, ...);
```

```C
#include <stdio.h>

int main (void)
{
    double width = 2.4, height = 0.76, depth = 3.14;   
    char info[100];
    const char format[] = "(%.2f x %.2f x %.2f)";

    sprintf(info, format, width, height, depth);

    puts(info);
    return 0;
}
```

Функцию sprintf часто используют для преобразования чисел в строки. 
```C
#include <stdio.h>

int main (void)
{
    int var_i = -123;
    char str_var[10];

    sprintf(str_var, "%d", var_i);

    puts(str_var);

    return 0;
}
```

Следующие функции определены в файле `<stdlib.h>`

```C
int atoi(const char* str);  // переводит строку в целое число
long atol(const char* str);  // переводит строку в long
long long atoll(const char* str);  // переводит строку в long long
double atof(const char* str);  // переводит строку в double
```

* atoi - строки в тип int
* atol - строки в тип long
* atoll - строки в тип long long
* atof - строки в float

```C
#include <stdio.h>
#include <stdlib.h>
 
int main(void) 
{
    int a = atoi("123");
    long b = atol("234235354");
    long long c = atoll("23423535456456");
    double d = atof("4564.4545");
 
    printf("a = %d\nb = %ld\nc = %lld\nd = %f\n", a, b, c, d);
 
    return 0;
}
```

# 6. Функции

## 6.1 Объявление и вызов функций

```markdown
<тип данных> <имя функции>([набор параметров с указанием типов])  <- заголовок (прототип функции)
{
    оператор_1;
    ...
    оператор_N;
}
```

Все операторы - это тело функции

Если функция ничего не возвращает, следует указывать тип void. 

Имена функциям следует давать глаголами.

При отсутствии параметров рекомеднуется прописывать void вместо них

Фигурные скобки по правилам пишутся на следующей строчке после прототипа

Прежде чем использовать объявленную функцию , необходимо убедиться, что она объявлена до этой функции, после директив и вне других функций.

Для вызова функции необходимо использовать оператор `()`

Локальные переменные окружения функции - это параметры, а копируемые в них значения при вызове - аргументы.

И да, при вызове функций происходит именно копирование данных

Оператор return возвращает то значение, что стоит после него

Количество аргументов должно соответствовать прототипу при вызове

## 6.2 Оператор return. Вызов функций в аргументах

return завершает работу программы и выводит соответствующее значение

* функции следует выполнять только свою узко поставленную задачу;
* для решения поставленной задачи, функции следует использовать только переданные ей параметры;
* если тело функции становится слишком большим ? это повод задуматься над правильностью организации логики программы; возможно, подзадачу следует раздробить на более мелкие подзадачи;
* в 99% случаях функции ничего не считывают с клавиатуры (из потока stdin) и ничего не выводят на экран (в поток stdout); если ваша функция делает это, убедитесь, что это действительно необходимо.

## 6.3 Прототипы функций

Бывают ситуации, когда необходимо объявить функции, а тела прописать позже.

```C
#include <stdio.h>

double per_sq(double w, double h);

int main (void)
{
    printf("per = %.2f\n", per_sq(2.5, 3.5));
    return 0;
}

double per_sq(double w, double h)
{
    if(w < 0 || h < 0)
        return 0;
    
    return 2 * (w + h);
}
```

Отдельные тела функций можно выносить в другие модули. Создаем файл `func.c`

`func.c` :
```C
double per_sq(double w, double h)
{
    if(w < 0 || h < 0)
        return 0;
    
    return 2 * (w + h);
}
```

`lessons.c` :
```C
#include <stdio.h>

double per_sq(double w, double h);

int main (void)
{
    printf("per = %.2f\n", per_sq(2.5, 3.5));
    return 0;
}
```

Теперь для использования функции per_sq в `main.c` необходимо в settings.json добавить параметр компиляции `func.c` после файла `lessons.c`

Есть один существенный минус. Если прототип изменится, то его придется менять во всех файлах. Поэтому прибегают к помощи заголовочных файлов.

Свои заголовочные файлы прописываем директивой include в кавычках.

## 6.4 Указатели как параметры. Передача массивов в функции

```C
#include <stdio.h>

void swap_2(int* a, int* b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

int main(void)
{
    int x = 5, y = 10;
    swap_2(&x, &y);
}
```

Также с помощью указателей можно передавать не только локальные переменные в другие функции и области памяти, а также еще и массивы. Нужно быть внимательным, что указатель на массив в функции не знает про то, сколько байтов занимает массив, поэтому размер мы передаем также, если нужно. Также, чтобы указать ,что мы передаем именно указатель на массив, можно использовать не только синтаксис
```C
int sum_ar(const short* arr, int length);
```
Но еще и
```C
int sum_ar(const short arr[], int length);
```

Двумерные массивы в списке передаем так:

```C
void show_ar2D(const short (*ar)[3], int rows)
{
    for(int i = 0;i < rows; ++i) {
        for(int j = 0;j < 3; ++j)
            printf("%d ", ar[i][j]);
        printf("\n");
    }
}

int main(void) 
{
    short ar[][3] = {{1, 2, 3}, {4, 5, 6}};
    show_ar2D(ar, sizeof(ar) / sizeof(*ar));
         
    return 0;
}
```

Недостаток в 3-ке , можно вынести его как макроопределение либо использовать индексацию как с одномерным массивом.

## 6.5 Указатели на функцию. Функция как параметр (callback)

Синтаксис указателя на функцию:
```markdown
<тип> (*<имя указателя>) ([<набор типов параметров>]);
```

C помощью указателя на функции можно строить функции фильтры:

```C
#include <stdio.h>
 
#define SIZE        10
 
void filter(int dst[], size_t size_dst, 
                            const int src[], size_t size_src, 
                            int (*is_correct)(int))
{
         for(int i = 0; i < size_dst; ++i)
                   dst[i] = 0;
 
         for(int i = 0, j = 0; i < size_src; ++i)
                   if(is_correct(src[i]))
                            dst[j++] = src[i];
}
 
int is_even(int x)
{
         return x % 2 == 0;
}
 
int main(void) 
{
         int digits[] = {-3, 4, 10, 11, -5, 3};
         int result[SIZE];
 
         filter(result, SIZE, digits, sizeof(digits) / sizeof(*digits), is_even);
         
         for(int i = 0; i < SIZE; ++i)
                   printf("%d ", result[i]);
 
         return 0;
}
```

Также можно объявлять массивы указателей на функции:
```markdown
<тип> (*<имя массива>[<размер массива>]) (<параметры>);
```

```C
int (*criterials[]) (int) = {is_even, is_odd, is_positive};
filter(result, SIZE, digits, sizeof(digits) / sizeof(*digits), criterials[1]);
```

## 6.6 Стековый фрейм. Автоматические переменные


При начале работы программы выделяется область памяти под стек вызовов функций

```C
int max2(int a, int b)
{
    return (a > b) ? a : b;
}

int main(void)
{
    int x = 1; y = 2;
    int res = max2(x, y);

    return 0;
}
```

При работе этой программы в стек заносится функция main с ее локальными переменными. Далее из этой функции происходит вызов функции max2 и она вместе со своими локальными  добавляется в стековый фрейм наверх функции main. Затем завершается исполнения функции max2 и ее локальные переменные пропадают вместе с ней из фрейма.

Переменные, объявленные внутри функции main, автоматически создаются в момент ее вызова и пропадают после ее завершения. Такие переменные называются автоматические. А их область видимости ограничивается телом функции.

При начале программы вызывается функция main, то есть в стековый фрейм передаются возвращаемое значение main (int) , параметры (void) и адрес возврата значения (__ret_main). Затем с помощью команды call _main мы переходим на программу main и выполняем ее. При вызове функций в языке C автоматически выделяется место для хранения ее локальных переменных. То есть переменные, которые мы объявляем в функции main распологаются в стековом фрейме.

## 6.7 Рекурсивные функции

```C
#include <stdio.h>
 
void rcs(int x)
{
    printf("Down: x = %d\n", x);
 
    if(x > 1)
        rcs(x-1);
 
    printf("Up: x = %d\n", x);
}
 
int main(void) 
{
    rcs(4);
 
    return 0;
}
```

```markdown
Down: x = 4

После проверки условия снова вызывается функция rcs(3) с аргументом 3. В стек помещается новое значение параметра x=3 и выполнение начинается с самого начала функции. Снова отрабатывает printf() с выводом на экран следующей строчки:

Down: x = 3

И так далее. Для rcs(2) увидим строку:

Down: x = 2

а для rcs(1) строчку:

Down: x = 1

После этого переходим на проверку условия. Оно оказывается ложным, поэтому попадаем на вторую функцию printf(), которая выводит сообщение:

Up: x = 1

Что происходит дальше? Из стека извлекается адрес возврата на вторую функцию printf(), указатель стека перемещается на предыдущий блок данных, в которых параметр x равен 2. Поэтому функция printf() отрабатывает с этим значением x=2. Видим на экране строку:

Up: x = 2

На этом выполнение функции завершается. Снова берется из стека адрес возврата на вторую функцию printf(), указатель стека перемещается на блок с данными предыдущего вызова, в котором x = 3. Получаем строку:

Up: x = 3

И также с последним вызовом:

Up: x = 4
```

Максимальное число вызовов функции самой себя же - это глубина рекурсии

Задача на игру в сапера: открытие всех нулей с началом в точке i j.

```C
#include <stdio.h>

#define N   5

void show_pole(const char (*p)[N])
{
    for(int i = 0; i < N; ++i) {
        for(int j = 0; j < N; ++j)
            printf("%c ", (p[i][j] == 0) ? '#' : '0');
        putchar('\n');
        }
}

void open_zeros(const char (*p)[N], char (*pp)[N], int i, int j)
{   
    if (p[i][j] != 0 || pp[i][j] == 1)
        return;
    
    pp[i][j] = 1;
    if(i-1 >= 0 && p[i-1][j] == 0) open_zeros(p, pp, i-1, j);
    if(i+1 < N && p[i+1][j] == 0) open_zeros(p, pp, i+1, j);
    if(j-1 >= 0 && p[i][j-1] == 0) open_zeros(p, pp, i, j-1);
    if(j+1 < N && p[i][j+1] == 0) open_zeros(p, pp, i, j+1);
}

int main(void)
{
    char pole[N][N] = {
        {1, 1, 1, 1, 1},
        {1, 1, 0, 1, 1},
        {0, 0, 0, 0, 0},
        {1, 1, 0, 0, 0},
        {1, 1, 0, 1, 1},
    };

    char ppole[N][N] = {0};
    show_pole(ppole);

    open_zeros(pole, ppole, 2, 2);
    puts("----------------");
    show_pole(ppole);

    return 0;
}
```

Рекурсивные функции очень удобны, когда нам нужно перебрать иерархические данные

Недостатки рекурсивных функций:

* рекурсивные вызовы работаю медленнее, чем итерации операторов циклов, поэтому, если задачу относительно просто можно реализовать через циклы, то именно их и следует применять;
* рекурсия не может идти до бесконечности; программа аварийно завершится, когда фреймовый стек будет полностью заполнен, поэтому если в задаче сложно оценить максимальную глубину рекурсии, то от использования рекурсивных функций лучше отказаться.

Кодирование Морзе:
```C
#include <stdio.h>
#include <string.h>

void translate_str(char *morse[], char symbols[], char src[], char dst[])
{
    int len = (int)strlen(src);
    for(int i = 0; i < len; ++i) {
        char* ptr_symbols_start = symbols;
        char* symb_ptr_in_symbols = strchr(symbols, src[i]);
        if(symb_ptr_in_symbols == NULL)
            symb_ptr_in_symbols = strchr(symbols, src[i]-32);
        int symb_indx = symb_ptr_in_symbols - ptr_symbols_start;
        strcat(dst, morse[symb_indx]);
        strcat(dst, " ");
    }
    dst[strlen(dst)-1] = '\0';
}

int main(void)
{
    char str[100];
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    char res[200] = "";
    char symbols[] = "AJS2BKT3CLU4DMV5ENW6FOX7GPY8HQZ9IR10 ";

    char *morse[] = {".-", ".---",	"...", "..---", "-...", "-.-", "-", 
                     "...--", "-.-.", ".-..", "..-", "....-", "-..", "--", 
                     "...-", ".....", ".", "-.", ".--", "-....", "..-.", 
                     "---", "-..-", "--...", "--.", ".--.", "-.--", 
                     "---..", "....", "--.-", "--..", "----.", "..", ".-.", 
                     ".----", "-----", "-...-"};
    
    translate_str(morse, symbols, str, res);
    puts(res);
    
    return 0;
}
```

Декодирование Морзе:
```C
#include <stdio.h>
#include <string.h>

#define MORSE_LEN   37

void translate_str(char *morse[], char symbols[], char src[], char dst[])
{
    char* ptr_end = strchr(src, ' ');
    char* ptr_start = src;
    while(ptr_end != NULL) {
        int i = 0;
        char current_morse_symb[10] = "";
        while(ptr_start+i != ptr_end) {
            current_morse_symb[i] = *(ptr_start+i);
            ++i;
        }
        current_morse_symb[i] = '\0';
        for(int j = 0; j < MORSE_LEN; ++j) {
            if(strcmp(morse[j], current_morse_symb) == 0) {
                char current_symb_ptr[2];
                sprintf(current_symb_ptr, "%c", symbols[j]);
                strcat(dst, current_symb_ptr);
                break;
            }
        }
        ptr_start = ptr_end + 1;
        ptr_end = strchr(ptr_end + 1, ' ');
    }
}

int main(void)
{
    char str[100];
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    char res[200] = "";
    char symbols[] = "AJS2BKT3CLU4DMV5ENW6FOX7GPY8HQZ9IR10 ";

    char *morse[] = {".-", ".---",	"...", "..---", "-...", "-.-", "-", 
                     "...--", "-.-.", ".-..", "..-", "....-", "-..", "--", 
                     "...-", ".....", ".", "-.", ".--", "-....", "..-.", 
                     "---", "-..-", "--...", "--.", ".--.", "-.--", 
                     "---..", "....", "--.-", "--..", "----.", "..", ".-.", 
                     ".----", "-----", "-...-"};
    if(str[strlen(str)-1] != ' ') {
        str[strlen(str)] = ' ';
        str[strlen(str)+1] = '\0';
    }
    translate_str(morse, symbols, str, res);
    puts(res);
    
    return 0;
}
```

## 6.8 Функции с произвольным числом параметров

Такие функции называют вариадическими.

Чтобы объявить такую функцию нужно импортировать `<stdarg.h>` и поставить ... . В этом заголовочном файле определен тип данных va_list. Теперь нам нужно, ссылаться на первый элемент этого потока. Используем функцию va_start(arg, count) , где count - это последний параметр функции до троеточия. Чтобы обращаться к аргументу из потока, необходимо использовать функцию va_arg(arg, int); - она во-первых понимает, как ей интерпретировать байты, а во-вторых сама итерируется по элементам. После конца перебора обязательно его заканчиваем функцией va_end(arg);.

```C
#include <stdio.h>
#include <stdarg.h>

int sum(int count, ...)
{
    int s = 0;
    va_list arg;
    va_start(arg, count);

    for(int i = 0; i < count; ++i) {
        s += va_arg(arg, int);
    }

    va_end(arg);
    return s;
}
```

Давайте рассмотрим, как это все работает:
В момент вызова функции, все аргументы, которые мы ей передаем, они заносятся в стековый фрейм, причем заносятся с конца

Функция va_start(arg, count) инициализирует указатель arg на параметр после count.

# 7. Классы памяти. Составные типы

## 7.1 Локальные и глобальные переменные

области видимости переменных

```C
#include <stdio.h>
/* Внешний блок кода */
char name[] = "Variables";
 
int main(void) 
{
    int var_main;  /* внутренняя переменная */
    return 0;
}
```

Внутренние (локальные) переменные функции во время ее вызова автоматически создаются и помещаются в стековый фрейм. Затем после выхода из функций эти автоматические переменные перестают быть доступны программе и на их место теперь можно записывать новые значения переменных. Про такие переменные говорят, что они имеют область видимости в пределах функции. 

Все переменные из внешнего блока размещаются либо в секции .bss (если не инициализированны начальными значениями) либо в секции data, если начальная инициализация присутствует. Переменные, располагающиеся в секциях .bss или .data появляются в момент загрузки программы и существуют на всем протяжение работы. Про такие переменные говорят, что они имеют глобальную область видимости. Все глобальные переменные, непроинициализированные в начале, принимают значения 0, а данные в секцию .data загружаются из текста программы в момент ее загрузки

## 7.2 Локальные переменные во вложенных блоках

В языке C фигурные скобки образуют свой собственный независимый блок с локальными переменными

Операторы if, while, for, do-while образуют свои собственные блоки. 

Мы можем попросить компилятор положить значение переменной поближе к процессору, непосредственно в его ячейки памяти с помощью ключевого слова register. 

## 7.3 Ключевые слова static и extern

Переменные, которые появились в начале работы программы и существуют до ее завершения, не изменяя своего адреса называют статическими. Это слово относится именно к адресу переменной

Язык С позволяет обычную локальную переменную сделать статической с помощью ключевого слова static. Такие переменные также размещаются в секции .bss, если не были инициализированы, и если были, то в .data. 
```C
static int var_st;
```
На самом деле здесь var_st - это указатель на заранее выделенную область памяти в 4 байта. 

Особенности таких переменных:
* Возможность не располагаться в стековом фрейме и не мешаться там.
* Однократная инициализация. В памяти она создается только один раз и продолжает существовать даже после завершения работы функции 

```C
#include <stdio.h>
 
unsigned int counter()
{
    static unsigned int cnt = 10;
    return ++cnt;
}
 
int main(void) 
{
    unsigned int times;
    times = counter();
    printf("times = %u\n", times);
    printf("counter(): %u\n", counter());
    printf("counter(): %u\n", counter());
    printf("counter(): %u\n", counter());
 
    return 0;
}
```

Чтобы воспользоваться переменной, определенной в другом файле: в нужном файле пишем
```C
extern int var;
```
Значение дублировать не нужно. Через extern не нужно прописывать размерность массива.

Если мы не хотим, чтобы переменная была видна в других модулях, прописываем ключевое слово static перед ней

## 7.4 Функции malloc(), free(), calloc(), realloc(), memcpy()

Обычные переменные, которыми мы пользовались ранее, располагаются либо в секциях .bss и .data , либо в стековом фрейме. И то и другое накладывает на нас ограничения. Остальная память программы, ничем не используемая, называется кучей "Heap". В этой куче можно самостоятельно выделять себе память и в последствие ее очищать. Для этого в заголовочном файле stdlib.h определено две функции:
```C
void* malloc(size_t size);  // для выделения size байт из кучи
void free(void* ptr);  // для освобождения памяти по указателю ptr.
```

Выделим непрерывную область памяти из 10 байтов:
```C
#include <stdio.h>
#include <stdlib.h>

int main(void)
{   
    char *ar = malloc(10);
    free(ar);  // не забудем очистить память
    return 0;
}
```

Главная Ахилесова пята языка программирования C - это утечки памяти. Когда память выделяется и не освобождается 

Реализуем динамический массив:
```C
#include <stdio.h>
#include <stdlib.h>

void* append(int* ar, int* length, int* capacity, int value)
{
    if(*length >= *capacity) {
        int* tmp_ptr = malloc(sizeof(int) * 2 * *capacity);
        if(tmp_ptr == NULL) return ar;
        (*capacity) *= 2;

        for(int i = 0; i < *length; ++i) {   
            tmp_ptr[i] = ar[i];
        }
        free(ar);
        ar = tmp_ptr;
    }

    ar[*length] = value;
    (*length)++;
    return ar;
}

int main(void)
{
    int capacity = 10;
    int length = 0;

    int *data = malloc(sizeof(int) * capacity);

    for(int i = 0; i < 11; ++i) {
        data = append(data, &length, &capacity, rand()%10);
    }

    for(int i = 0; i < length; ++i) 
        printf("%d ", data[i]);

    printf("\ncapacity - %d, length - %d", capacity, length);
    return 0;
}
```

Дополнительные функции:
```C
--stdlib.h--
void* calloc(size_t nmemb, size_t size);  // выделяет память для nmemb элементов, каждый размером size байтов и заполняет нулями
void* realloc(void *ptr, size_t length);  // служит для изменения размера ранее выделенной памяти, на которое ведет указатель ptr, а новый размер: length. length = 0, realloc =(тожд) free.

--string.h--
void* memcpy(void* restrict dst, const void* restrict src, size_t length);  // копирование одной строки в другую
void* memmove(void* dst, const void* src, size_t length);  // копирование одного фрагмента строки в другую строку
```

restrict означает, что каждый из указателей ведет на свою, непересекающуюся ни с чем область памяти.

## 7.5 Перечисления (enum). Директива typedef

Перечисления - отдельный тип данных в C , который позволяет определять набор целочисленных констант в программе

```C
enum colors {
    red,
    green,
    blue
};
```

Значение констант enum формируются в момент компиляции программы, то есть константы в enum - это константы времени компиляции. Поэтому их можно использовать в switch-case. Все константы в enum приобретают целочисленные значения, начиная с нуля

```C
enum keys {vk_enter=27, vk_space, vk_leave=30};
enum {
    go = 0x1f00, 
    stop = 0x0001, 
    forward = go,
    run = 0x00a2,
    back = run -1
};
```

enum keys - это новый тип данных. Поэтому делаем так:
```C
#include <stdio.h>
 
enum keys {vk_enter=27, vk_space, vk_del=30};
 
int main(void) 
{
    enum keys k_var = vk_enter;
 
    switch(k_var) {
    case vk_enter:
        puts("vk_enter");
        break;
    case vk_space:
        puts("vk_space");
        break;
    }
 
    return 0;
}
```

При таком переборе возникнет предупреждение программисту, что он забыл третью константу в перечислении.

Если нам нужно определить не локальную переменную этого типа, а глобальную, то после перечисления, после {}, ставим название этой переменной:
```C
enum colors {red, green, blue} wnd_colors;
 
enum {
    go = 0x1f00, 
    stop = 0x0001, 
    forward = go,
    run = 0x00a2,
    back = run -1
} actions, commands;
```

#### Директива typedef

Она позволяет задать пользовательское имя типа

```C
typedef unsigned char BYTE;
 
int main(void) 
{
    BYTE byte;
    BYTE ch, var_ch = '0';
 
    return 0;
}
```

Директива typedef обрабатывается не препроцессором, а самим компилятором, а потому это более тонкое и безопасное действие.

```C
#include <stdio.h>
 
#define PTR_INT int*
 
typedef int* PTR;
 
int main(void) 
{
    PTR_INT a, b;      // int* a, b;
    PTR ptr_a, ptr_b;  // int *ptr_a, *ptr_b;
    printf("*a = %d, *b = %d\n", *a, *b);
    printf("*ptr_a = %d, *ptr_b = %d\n", *ptr_a, *ptr_b);
 
    return 0;
}
```

Довольно часто директиву typedef определяют для перечислений enum:
```C
#include <stdio.h>

typedef enum {
    buffer_size = 2048,
    element_size = 12,
    window_size = 400
} SIZE_CONSTS;

int main(void)
{
    SIZE_CONSTS constant = window_size;
    printf("%d\n", sizes);
    printf("%d\n", buffer_size);

    return 0;
}
```

```C
#include <stdio.h>
#include <stdlib.h>
 
int is_even(int x)
{
    return x % 2 == 0;
}
 
typedef int (*PTR_EVEN)(int);
typedef char (*PTR_AR_2D)[4];
 
int main(void) 
{
    char ar_2d[5][4] = {0};
    PTR_AR_2D ptr_2d = ar_2d;
    ar_2d[1][2] = 5;
   
    PTR_EVEN func_even = is_even;
 
    printf("%d\n", func_even(2));
    printf("%d\n", func_even(3));
 
    printf("%d\n", ptr_2d[1][2]);
 
    return 0;
}
```

## 7.6 Структуры. Вложенные структуры

```C
struct tag_point {
    int x;
    int y;
    int z;
};
```

Конструкция struct - есть новый тип данных, которая не создает ничего нового.

```C
int main(void) 
{
    struct tag_point pt;
    return 0;
}
```

В итоге в памяти компьютера будет выделелен непрерывный участок, где по очереди будут хранится поля x, y, z . Также компилятор на этом этапе может добавить некоторые выравнивающие байты. Это связано с быстротой чтения данных компилятором. Объявлять значение полей можно используя операцию точку:

```C
pt.x = 1;
pt.y = 2;
pt.z = 3;
```

Инициализировать поля структуры можно следующим образом:

```C
struct tag_point pt = {10, 20, 30};
struct tag_point pt = {10};
struct tag_point pt = {};
```

Конкретным полям можно задавать свои значения так:

```C
struct tag_point pt = {.y = -1, .x = 2};
```

В качестве полей структуры, можно использовать и другие структуры. Это называется вложенные структуры.

```C
enum {name_length=50, b_length=20};
 
struct tag_fio {
    char name[name_length]; /* имя */
    char last[name_length]; /* фамилия */
};

struct tag_person {
    struct tag_fio fio;     /* ФИО */
    char sex;               /* пол: м или ж */
    unsigned short old;     /* возраст */
    char b_date[b_length];   /* дата рождения */
};
```

Тогда инициализация вложенной структуры может выглядить таким образом:

```C
int main(void) 
{
    struct tag_person person = {
        {"Sergey", "Balakirev"},
        'M',
        98,
        "32.07.1925"
    };
 
    return 0;
}
```

```C
printf("name: %s, last: %s\n", person.fio.name, person.fio.last);
```

Структуры можно копировать операцией присваивания

```C
struct tag_person p;
p = person;
```

## 7.7 Указатели на структуры. Передача структур в функции

```C
struct tag_vector {
    double x;
    double y;
};

int main(void) 
{
    struct tag_vector v = {1.0, 2.0};
    struct tag_vector *ptr_v;
    
    ptr_v = &v;

    return 0;
}
```

Теперь ptr_v - есть указатель на структуру v, чтобы получить доступ к элементам структуры, нужно разыменовать указатель:
```C
(*ptr_v).x = 10.0;
```

Для указателей на структуры существует специальная операция -> для доступа к полям этой структуры через указатели:

```C
ptr_v->x = 5.0;
```

Также, для экономии места в стековом фрейме можно использовать кучу и функцию malloc:

```C
ptr_v = malloc(sizeof(struct tag_vector));
```

Соответственно запишем туда значения стрелочкой:
```C
ptr_v->x = 1.0;
ptr_v->y = 2.0;
```

Рассмотрим возврат структур из функций:
```C
#include <stdio.h>

struct tag_vector create_vector(double x, double y)
{
    struct tag_vector v = {x, y};
    return v;
}

int main(void) 
{
    struct tag_vector bias = create_vector(2.56, -7.88);
    printf("bias.x = %.2f, bias.y = %.2f\n", bias.x, bias.y);
 
    return 0;
}
```

Этот код ужасен тем, что во-первых в функции (а потому в и без того маленьком стековом фрейме) создается структура, и при завершении работы, эта функция копирует структуру в другую область памяти в стековом фрейме. Поэтому логичнее было бы задействовать кучу и работать в функции не с самой структурой, а ее указателем:
```C
struct tag_vector* create_vector(double x, double y)
{
    struct tag_vector* v = malloc(sizeof(struct tag_vector));
    v->x = x;
    v->y = y;
    
    return v;
}

int main(void) 
{
    struct tag_vector* bias = create_vector(2.56, -7.88);
    printf("bias.x = %.2f, bias.y = %.2f\n", bias->x, bias->y);
 
    free(bias);
    return 0;
}
```

Передача структур в функции:
```C
struct tag_vector sum_vector(const struct tag_vector v1, const struct tag_vector v2)
{
    struct tag_vector res = {v1.x + v2.x, v1.y + v2.y};
    return res;
}
```

Структуры можно создавать непосредственно перед передачей в функции:

```C
isum_vector(&bias, &(struct tag_vector) {0.5, -0.5});
```

## 7.8 Реализация стека (пример использования структур)

Введем структуру, которая будет иметь свои данные и информацию про следующую такую же структуру. Соответственно самая первая структуру не должна иметь информацию про следующую структуру, будет ссылаться просто на NULL. Введем так же указатель top для того, чтобы понимать, какая структура на данный момент является последней.

```C
#include <stdio.h>
#include <stdlib.h>

typedef struct tag_obj {
    int data;
    struct tag_obj* next;
} OBJ;

```

Когда мы в структуре используем тип данных, который в данный момент и объявляем, такой тип данных называется неполным.

```C
int main (void)
{
    OBJ* top = NULL;
    return 0;
}
```

Создадим функцию добавления элемента в стек и удаления:

```C
OBJ* push(OBJ* top, const char* url)
{
    OBJ* ptr = malloc(sizeof(OBJ));
    strcpy(ptr->url, url);
    ptr->next = top;
    return ptr;
}

OBJ* pop(OBJ* top)
{
    if(top == NULL) return top;
    OBJ* ptr = top->next;
    free(top);
    return ptr;
}
```

## 7.9 Объединения (union). Битовые поля

Синтаксис объединения:

```markdown
union [имя объединения] {
    [поля (через ;)]
};
```
Пример:

```C
union tag_var {
    char var_ch;
    int var_i;
    double var_d;
};
```

Если бы это была структура, то тогда все эти поля хранились бы друг за дружкой. Здесь же поля хранятся в одном непрерывном участке памяти, размером с размер максимального типа данных из перечисленных полей. Соответственно в юнионе можно хранить одновременно всего один тип данных в какой-то момент времени.

Для объявления переменной типа union:

```C
union tag_var var;
var.var_ch = 'C';
```

В данный момент первый байт принимает значение 'C', а другие - неопределенное значение.

Для передачи юнионов в функции поступаем точно так же, как и со структурами:

```C
#include <stdio.h>
#include <string.h>

typedef enum {
    union_var_none, union_var_ch, union_var_i, union_var_d
} TYPE_VAR;

union tag_var {
    char var_ch;
    int var_i;
    double var_d;
};

void show_var(union tag_var v, TYPE_VAR type)
{
    switch(type) {
        case union_var_ch: 
            printf("var_ch = %c\n", v.var_ch);
            break;
        case union_var_i: 
            printf("var_i = %d\n", v.var_i);
            break;
        case union_var_d: 
            printf("var_d = %.2lf\n", v.var_d);
            break;
        case union_var_none:
            puts("Undefined type var");
            break;
    };
}

int main(void)
{
    union tag_var var;

    var.var_ch = 'C';
    // var.var_i = 45;

    show_var(var, union_var_ch);

    return 0;
}
```

В действительности, мы никак не можем узнать, какой тип данных конкретно сейчас хранит юнион. Поэтому желательно иметь переменную, которая будет на это намекать. Кстати логично здесь использовать enum.

Еще правильней будет объявить структуру, с типом данных и сами данными:

```C
#include <stdio.h>
#include <string.h>

typedef enum {
    union_var_none, union_var_ch, union_var_i, union_var_d
} TYPE_VAR;

union tag_var {
    char var_ch;
    int var_i;
    double var_d;
};

typedef struct {
    union tag_var var;
    TYPE_VAR type;
} VAR;

void show_var(VAR v)
{
    switch(v.type) {
        case union_var_ch: 
            printf("var_ch = %c\n", v.var.var_ch);
            break;
        case union_var_i: 
            printf("var_i = %d\n", v.var.var_i);
            break;
        case union_var_d: 
            printf("var_d = %.2lf\n", v.var.var_d);
            break;
        case union_var_none:
            puts("Undefined type var");
            break;
    };
}

int main(void)
{
    VAR var = {67, union_var_i};

    show_var(var);

    return 0;
}
```

### Битовые поля.

В C есть возможность создавать структуры с целочисленными полями и дополнительно к этому явным образом указывать количество битов, которые будут там храниться.

```C
#include <stdio.h>

struct date_time {
    unsigned day : 5;
    unsigned month : 4;
    unsigned year : 12;
    unsigned sec : 6;
    unsigned min : 6;
    unsigned hour : 5;
};

int main(void)
{
    struct date_time dt;
    printf("%d\n", sizeof(dt));

    return 0;
}
```

Для определения битовых полей в стандарте языка C нужно прописывать тип unsigned. В силу того, что память, занимаемая этой структурой кратна размеру инта, то суммарно эта структура займет: 5 + 4 + 12 + 6 + 6 + 5 = 38 бит, но хранится это будет в двух интах (в инте 32 бита) , соответственно 4*2 байта => 8 байтов.

Примечательно то, что можно создавать анонимный массив объектов объединения следующим образом:

```C
#include <stdio.h>

typedef enum {param_int, param_double} TYPE_PARAM;

typedef union {
    int data_i;
    double data_d;
} DATA;

DATA sum_ar(DATA ar[], size_t elem_num, TYPE_PARAM type)
{
    DATA res;
    switch(type) {
        case param_int:
            for(int i = 0; i < elem_num; ++i) res.data_i += ar[i].data_i;
            break;
        case param_double:
            for(int i = 0; i < elem_num; ++i) res.data_d += ar[i].data_d;
            break;
    }
    
    return res;
}

int main (void)
{
    DATA res_1, res_2;
    res_1 = sum_ar((DATA []){(DATA){.data_i=1}, (DATA){.data_i=2}, (DATA){.data_i=3}, (DATA){.data_i=4}, (DATA){.data_i=5}}, 5, param_int);
    
    res_2 = sum_ar((DATA []){(DATA){.data_d=1.1}, (DATA){.data_d=2.2}, (DATA){.data_d=3.3}, (DATA){.data_d=4.4}, (DATA){.data_d=5.5}}, 5, param_double);
    
    return 0;
}
```

# 8. Работа с файлами

## 8.1 Файловые функции: fopen(), fclose(), fgetc(), fputc()

Абсолютные пути желательно прописывать обычными слэшами:

```markdown
"d:/app/my_file.txt"
```

Для работы с файлами в языке C используются так называемые потоки. Именно через них происходит чтение данных из файла или запись данных в файл.

Для открытия файлового потока использутеся функция fopen. Объявление следующее: (в заг. файле <stdio.h>)

```C
FILE* fopen(const char* path, const char* mode);
```

Здесь path - это абсолютный или относительный путь, mode - режим работы с потоком. Виды mode:

* r - Открытие на чтение;
* w - Открытие на запись. Если не существует, то создается, если существует, перезаписывается;
* a - Открытие на дозапись. Есле не существует, то создается;
* r+ - Открытие на чтение и запись одновременно;
* w+ - Открытие на чтение и запись. Если файл не существует, то создается, существует, то перезаписывается.
* a+ - Открытие на чтение и запись. Добавлять можно только в конец, а читать все. Если файл не существует, он создается.

Для всех этих режимов доступны еще надстройки в виде бинарных режимов: 
* rb;
* wb;
* ab;
* rb+;
* wb+;
* ab+.

То же самое, только бинарно.

Эта функция fopen возвращает указатель на файл типа FILE* , и этот файл связан с открытым потоком. Либо мы получаем NULL, если по каким-то причинам открыть файл не удалось.

__Что же из себя преставляет файловый поток?__

Функция fopen делает системный запрос к операционной системе на открытие файлового потока. ОС выполняет необходимые действия и в случае успеха возвращает дескриптор файлового потока. Дополнительно функция fopen создает входной буффер при чтении данных из файла, или выходной при записи. Делается это потому, что работа с файлами (чтение или запись) происходит не побайтово. Используются сразу порции байтов. При записи данных в файл, первым делом заполняется выходной буффер файлового потока. В случае его заполнения происходит выгрузка байтов в файл. Так же обстоят дела с чтением из файла. Происходит так в целях экономии времени на запросах к ОС, ведь это дело небыстрое.

После успешного открытия файла строго обязательно вызывать функцию закрытия файла:

```C
int fclose(FILE* fp);
```

Данная функция разгребает оставшиеся байты в буфферах, очищает их, и завершает все сеансы, связанные с этим файловым потоком. Функция возвращает 0, если закрытие файла прошло успешно, и -1 при возникновении какой-то ошибки.

Пример использования функций:

```C
#include <stdio.h>

int main(void)
{
    FILE* fp = fopen("my_file.txt", "w");
    if(fp == NULL) return 1;

    fclose(fp);
    return 0;
}
```

В директории проекта создался текстовый файл my_file.txt

Теперь запишем сюда что-нибудь следующими функциями:

```C
int fgetc(FILE* stream);  // для чтения одного байта
int fputc(int ch, FILE* stream);  // для записи одного байта
```

В качестве потоков могут фигурировать и стандартные потоки ввода/вывода stdin/stdout.

Пример записи в файл побайтово:

```C
#include <stdio.h>
#include <string.h>

int main(void)
{
    char str[] = "Function fputc() in action.";

    FILE* fp = fopen("my_file.txt", "w");
    if(fp == NULL) return 1;

    for(int i = 0; i < strlen(str); ++i) {
        fputc(str[i], fp);
    }

    fclose(fp);
    return 0;
}
```

Если мы не закрываем файловый поток, то некоторые данные могут быть не перенесены в файл. Поэтому всегда перед чтением убеждаемся, что файл был закрыт

```C
#include <stdio.h>
#include <string.h>

int main(void)
{
    char str[] = "Function fputc() in action.";
    char buff[100];

    FILE* fp = fopen("my_file.txt", "w");
    if(fp == NULL) return 1;

    for(int i = 0; i < strlen(str); ++i) {
        fputc(str[i], fp);
    }

    fclose(fp);

    FILE* in = fopen("my_file.txt", "r");
    if(in == NULL) return 2;

    char ch;
    int i = 0;
    while((ch = fgetc(in)) != EOF)
        buff[i++] = ch;
    buff[i] = '\0';

    puts(buff);

    fclose(in);
    return 0;
}
```

## 8.2 Функции perror(), fseek() и ftell()

Для более подробного сообщения программисту источника ошибки в заголовочном файле <errno.h> определен макрос errno. Есть специальная функция, которая сопоставляет коду ошибке errno собственное осмысленное сообщение ошибки:

```C
void perror(const char* );
```

```C
#include <stdio.h>
#include <string.h>
#include <errno.h>

int main(void)
{
    char str[] = "Function fputc() in action.";
    char buff[100];

    FILE* fp = fopen("my_file2.txt", "r");
    if(fp == NULL) {
        printf("errno: %d\n", errno);    
        perror("my_file2.txt");
        return 1;
    }

    for(int i = 0; i < strlen(str); ++i) {
        fputc(str[i], fp);
    }

    fclose(fp);
    return 0;
}
```

Более того, эта функция perror выводит текст ошибки в стандартный поток вывода ошибок stderr.

Теперь подумаем, откуда функция fgetc знает , какой символ читать далее? На самом деле специальный указатель in включает в себя указатель позиции, который указывает на очередной для считывания байт. При желании этим указателем можно управлять. 

```C
int fseek(FILE* stream, long offset, int whence);  // для установки позиции
long ftell(FILE* stream);  // для получения позиции
```

offset - смещение файловой позиции, а смещаем мы его относительно того, что указано в третьем параметре. В частности, мы можем указать следующее:

* SEEK_SET - от начала файла;
* SEEK_CUR - от текущей позиции;
* SEEK_END - от конца файла.

## 8.3 Функции fputs(), fgets() и fprintf(), fscanf()

```C
int fputs(const char* s, FILE* stream);  // запись строк
char* fgets(char* s, int size, FILE* stream);  // считывание строк
```

Функция fputs возвращает -1 в случае ошибки и другое значение при успешной записи данных
Функция fgets возвращает переданный указатель s или NULL если не удалось прочитать ни одной строки.

fgets формирует корректные с точки зрения языка C строки, добавляя в конец символ переноса строки \n. 

Теперь рассмотрим функции

```C
int fprintf(FILE* stream, const char* format, ...);  // запись данных
int fscanf(FILE* stream, const char* format, ...);  // чтение данных
```  

Пример форматного чтения данных: 

```C
#include <stdio.h>
#include <string.h>
#include <errno.h>

int main(void)
{
    double dollars[20];

    FILE* fp = fopen("data_rubusd.csv", "r");
    if(fp == NULL) {
        perror("data_rubusd.csv");
        return 1;
    }

    int index = 0;
    while(fscanf(fp, "%lf; ", &(dollars[index])) == 1)
        printf("%.2lf ", dollars[index++]);

    fclose(fp);

    return 0;
}
```

Файл data_rubusd.csv:

```markdown
78.43; 45.54; 65.67; 66.78; 88.9
```

Пример форматной записи в файл:

```C
#include <stdio.h>
#include <string.h>

int main(void)
{
    const char* phones[][5] = {
        {"8", "917", "123", "45", "98"},
        {"8", "915", "267", "25", "99"},
        {"8", "914", "165", "46", "78"},
        {"8", "913", "153", "35", "00"},
        {"8", "912", "112", "75", "09"},
    };

    FILE* fp = fopen("phones.txt", "w");
    if(fp == NULL) {
        perror("phones.txt");
        return 1;
    }

    for(int i = 0; i < sizeof(phones) / sizeof(*phones); ++i) {
        fprintf(fp, "%s(%s)%s-%s-%s\n", phones[i][0], phones[i][1], phones[i][2], phones[i][3], phones[i][4]);
    }

    fclose(fp);

    return 0;
}
```

## 8.4 Функции feof(), fflush(), setvbuf()

Давайте представим, что теперь нам нужно прочитать данные вот в таком формате:

```markdown
rub/usd
78.43; 78.65; 78.90; 80.10; 79.88; 80.23; 80.67; 81.22; 82.34; 81.54
rub/eur
88.43; 88.65; 88.90; 88.10; 89.88; 88.23; 88.67; 89.22; 90.34; 90.54; 90.23; 89.10
rub/yan
9.23; 9.44; 9.56; 9.32; 9.88; 10.01; 10.20; 10.11; 10.54; 10.78; 11.0; 11.04
```

Функция feof возвращает 1, если был достигнут символ EOF и 0 в пр. случае

```C
#include <stdio.h>
#include <string.h>

enum {max_length=100};

int main(void)
{
    double data[max_length];
    char buffer[max_length];
    int length = 0;

    FILE* fp = fopen("data_rubusd2.csv", "r");
    if(fp == NULL) {
        perror("data_rubusd2.csv");
        return 1;
    }

    while(!feof(fp)) {
        fgets(buffer, sizeof(buffer), fp);
        char* ptr_new_line = strrchr(buffer, '\n');
        if(ptr_new_line != NULL) *ptr_new_line = '\0';

        puts(buffer);

        length = 0;
        while(fscanf(fp, "%lf; ", &data[length]) == 1)
            ++length;
        
        for(int i = 0; i < length; ++i) printf("%.2lf ", data[i]);
        putchar('\n');
    }

    return 0;
}
```

Следующая функция fflush: как правило, она работает с выходными потоками

```C
int fflush(FILE* stream);  // очистка выходного потока
```

Пример использования: 

```C
#include <stdio.h>
#include <string.h>

enum {max_length=100};

int main(void)
{
    int data[] = {1, 2, 3, 4, 5, 4, 3, 2, 1, -1};
    int length = sizeof(data) / sizeof(*data);

    FILE* fp = fopen("write_and_read.dat", "w");
    FILE* in = fopen("write_and_read.dat", "r");

    if(fp == NULL || in == NULL) {
        perror("write_and_read.dat");
        return 1;
    }

    for(int i = 0; i < length; ++i) {
        fprintf(fp, "%d ", data[i]);
    }

    fflush(fp);

    char buffer[100];
    fgets(buffer, sizeof(buffer), in);
    char* ptr_new_line = strrchr(buffer, '\n');
    if(ptr_new_line != NULL) *ptr_new_line = '\0';

    puts(buffer);

    fclose(fp);
    fclose(in);
    return 0;
}
```

Следующая функция setvbuf. Когда fopen открывает файловый поток на чтение или запись, автоматически задается буффер. Так вот этот буфер можно переместить в , например, свой массив в программе.

```C
int setvbuf(FILE * restrict stream, char * restrict buf, int mode, size_t size);
```

```markdown
stream - файловый поток,
buf - область памяти под буфер,
mode - режим работы буфера,
size - размер буфера в байтах.
```

Режимы работы буфера:

* _IOFBF - полная буферизация (очистка после заполнения буфера);
* _IOLBF - построчная буферизация (очистка по символу переноса строки);
* _IONBF - выключение буферизации.

Функцию setvbuf желательно вызывать сразу после открытия файлового потока. Функция возвращает 0, если отработала правильно, и не ноль, когда что-то случилось.

## 8.5 Бинарный режим доступа. Функции fwrite() и fread()

Бинарный режим доступа незаменим, когда нам в файле необходимо сохранить значения некоторых переменных. Пусть:

```C
int var_i = -10;
double pi = 3.141592653589793;
char ch = 'S';
```

Бинарный режим доступа можно активировать, открыв файловый поток с режимом "rb" или "wb".

В языке C есть две удобные функции, которые помогут нам для работы в бинарном режиме:

```C
size_t fwrite(const void* restrict ptr, size_t size, size_t nmemb, FILE* restrict stream);  // функция для записи однотипных переменных в файл
size_t fread(void * restrict ptr, size_t size, size_t nmemb, FILE* restrict stream);  // функция для считывания из файла
```

```markdown
ptr - это указатель на область памяти, которую следует записать (или куда занести) данные;
size - размер однотипной порции данных для чтения / записи;
nmemb - количество элементов одного типа;
stream - файловый поток.
```

Пример записи файлов в бинарном режиме:

```C
#include <stdio.h>

int main(void)
{
    int var_i = -10;
    double pi = 3.141592653589793;
    char ch = 'S';

    FILE* fp = fopen("binary.txt", "wb");

    if(fp == NULL) {
        perror("binary.txt");
        return 1;
    }

    fwrite(&var_i, sizeof(var_i), 1, fp);
    fwrite(&pi, sizeof(pi), 1, fp);
    fwrite(&ch, sizeof(ch), 1, fp);

    fclose(fp);
    return 0;
}
```

Теперь прочитаем записанные данные:

```C
#include <stdio.h>

int main(void)
{
    int var_i;
    double pi;
    char ch;

    FILE* fp = fopen("binary.txt", "rb");

    if(fp == NULL) {
        perror("binary.txt");
        return 1;
    }

    fread(&var_i, sizeof(var_i), 1, fp);
    fread(&pi, sizeof(pi), 1, fp);
    fread(&ch, sizeof(ch), 1, fp);
    
    fclose(fp);

    printf("%d, %lf, %c", var_i, pi, ch);

    return 0;
}
```

Пусть у нас в программе объявлена структура, и в файл нужно сохранить массив из этих структур.

```C
#include <stdio.h>

enum {name_size=10};

typedef struct {
    char name[name_size];
    double x, y;
} POINT;


int main(void)
{
    POINT fig[] = {
        {"Point 1", 0.0, 0.0},
        {"Point 2", 4.23, -21.0},
        {"Point 3", 6.65, -31.34},
        {"Point 4", 3.2, -44.62},
        {"Point 5", -1.65, 1.0},
    };

    FILE* fp = fopen("figure.txt", "wb");
    if(fp == NULL) {
        perror("figure.txt");
        return 1;
    }

    int res = fwrite(fig, sizeof(POINT), sizeof(fig) / sizeof(*fig), fp);

    fclose(fp);

    printf("%d\n", res);

    return 0;
}
```

И теперь читаем:

```C
#include <stdio.h>

enum {name_size=10, max_points=50};

typedef struct {
    char name[name_size];
    double x, y;
} POINT;


int main(void)
{
    POINT fig[max_points];
    int length = 0;

    FILE* fp = fopen("figure.txt", "rb");
    if(fp == NULL) {
        perror("figure.txt");
        return 1;
    }

    while(fread(&fig[length], sizeof(POINT), 1, fp) == 1) {
        printf("Точка %d: (%.2lf, %.2lf)\n", length+1, fig[length].x, fig[length].y);
        ++length;
    }

    fclose(fp);

    return 0;
}
```

КОНЕЦ С.

Все права защищены и принадлежат мне